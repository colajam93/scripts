#!/usr/bin/env python3

import json
import os
import pathlib
import shutil
import subprocess
import typing
from argparse import ArgumentParser
from contextlib import closing
from tempfile import TemporaryDirectory, NamedTemporaryFile
from typing import List
from urllib.parse import quote
from urllib.request import urlopen

OFFICIAL_AUR_URL = 'https://aur.archlinux.org'

JSONType = typing.Union[str, int, float, bool, None, typing.Mapping[str, typing.Any], typing.List[typing.Any]]


class AURInfo(typing.NamedTuple):
    id: int
    name: str
    package_base_id: int
    package_base: str
    version: str
    description: str
    url: str
    num_votes: int
    popularity: float
    out_of_date: int
    maintainer: str
    first_submitted: int
    last_modified: int
    url_path: str

    @staticmethod
    def from_json(data: JSONType) -> 'AURInfo':
        name_mapping = {
            'id': 'ID',
            'name': 'Name',
            'package_base_id': 'PackageBaseID',
            'package_base': 'PackageBase',
            'version': 'Version',
            'description': 'Description',
            'url': 'URL',
            'num_votes': 'NumVotes',
            'popularity': 'Popularity',
            'out_of_date': 'OutOfDate',
            'maintainer': 'Maintainer',
            'first_submitted': 'FirstSubmitted',
            'last_modified': 'LastModified',
            'url_path': 'URLPath'
        }

        return AURInfo(**{k: data[v] for k, v in name_mapping.items()})


def info_url(packages: List[str], server: str = OFFICIAL_AUR_URL) -> str:
    return server + '/rpc/?v=5&type=info&' + '&'.join(['arg[]={}'.format(quote(x)) for x in packages])


def search_url(package: str, server: str = OFFICIAL_AUR_URL) -> str:
    return server + '/rpc/?v=5&type=search&arg={}'.format(quote(package))


def query(url: str):
    with closing(urlopen(url)) as request:
        return json.loads(request.read().decode())


def do_getpkgbuild(packages: List[str], directory: str) -> None:
    query_result = query(info_url(packages))
    if query_result['resultcount'] != len(packages):
        missing = set(packages) - {i['Name'] for i in query_result['results']}
        converted = (f'"{i}"' for i in missing)
        print(f'{", ".join(converted)} not found')
    with TemporaryDirectory() as temp_dir:
        for package in query_result['results']:
            with NamedTemporaryFile(dir=temp_dir) as t:
                with closing(urlopen(OFFICIAL_AUR_URL + package['URLPath'])) as request:
                    t.write(request.read())
                    t.flush()
                subprocess.run(['tar', 'xvf', t.name, '-C', temp_dir],
                               stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)

        output_directory = directory if directory else os.getcwd()
        path = pathlib.Path(temp_dir)
        gen = (x for x in path.iterdir() if x.is_dir())
        for d in gen:
            destination = shutil.move(str(d), output_directory)
            print(f'Saved to {destination}')


def do_sync_search(packages: List[str]) -> None:
    query_result = query(search_url(' '.join(packages)))
    for i in query_result['results']:
        info = AURInfo.from_json(i)
        print(f'aur/{info.name} {info.version}')
        print(f'    {info.description}')


def main() -> None:
    parser = ArgumentParser()
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--sync', '-S', action='store_true')
    group.add_argument('--getpkgbuild', '-G', action='store_true')
    parser.add_argument('package', nargs='+')
    parser.add_argument('--directory', '-d', default='')
    parser.add_argument('--search', '-s', action='store_true')
    args = parser.parse_args()

    if args.sync and args.search:
        do_sync_search(args.package)
    elif args.getpkgbuild:
        do_getpkgbuild(args.package, args.directory)


if __name__ == '__main__':
    main()
